#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

################################################################################
## Script written by Rafael Fernández López <ereslibre@kde.org>               ##
##                                                                            ##
##                                                                            ##
## This script is of PUBLIC DOMAIN.                                           ##
################################################################################

#### CONFIGURE #################################################################

INSTALL_PREFIX = "/usr/local"
INSTALL_COMMAND = "sudo make install/fast"
MAKE_OPTIONS = "-j5"
BUILD_TYPE = "Debug"
SOURCE_DIR = File.expand_path "~/proyectos"
DEFAULT_OBJECTIVE = :full_kde

#### INTERNAL ##################################################################

def user_has_own_config
  File.exists? File.join(ENV["HOME"], ".kdebuild")
end

def user_own_config
  File.new(File.join(ENV["HOME"], ".kdebuild")).read
end

def known_task(task)
  $tasks.has_key? task.to_sym
end

begin
  require "json" if user_has_own_config
rescue LoadError
  puts "!!! You have set your own configuration on #{File.join(ENV["HOME"], ".kdebuild")}, and this"
  puts "    format is JSON. In order to be able to understand the configuration file you need to run:"
  puts
  puts "    # sudo gem install json"
  Process.exit 1
end

$stderr.reopen "/dev/null"

ENV["PATH"] = "#{INSTALL_PREFIX}/bin:#{ENV["PATH"]}"
ENV["PKG_CONFIG_PATH"] = "#{INSTALL_PREFIX}/lib/pkgconfig:#{ENV["PKG_CONFIG_PATH"]}"

require "fileutils"

$options = {}
$options[:build_only] = false
$options[:omit_dependencies] = false
$options[:list_available_tasks] = false
$options[:force_cmake] = false
$options[:verbose] = false

$tasks = Hash.new
$failed_tasks = { :configure => Array.new,
                  :build     => Array.new,
                  :install   => Array.new }
$succeeded_tasks = Array.new

def info(info_msg)
  puts "\t-> #{info_msg}..."
end

class Repository

  attr_reader :uri

  SVN_REPO = 0
  GIT_REPO = 1

  def initialize(uri, type)
    @uri = uri
    @type = type
  end

  def clone
    if @type == SVN_REPO
      info "Doing checkout of SVN repository"
      IO.popen("svn co #{uri} . &> /dev/null") {}
    else
      info "Cloning git repository"
      IO.popen("git clone #{uri} . &> /dev/null") {}
    end
    true
  end

  def update
    if @type == SVN_REPO
      info "Updating SVN repository"
      (IO.popen("svn up").read =~ /Updated to revision \d+\./) != nil
    else
      info "Updating git repository"
      IO.popen("git pull origin master").read !~ /Already up-to-date\./
    end
  end

end

class Task

  attr_reader :name, :repository, :dependencies

  CMAKE = 0
  QMAKE = 1

  def initialize(name, source, repository, dependencies = nil, build_system = CMAKE)
    @name = name
    @source = source
    @repository = repository
    @dependencies = dependencies
    @build_system = build_system
    @install_command = INSTALL_COMMAND
    @touched = false
    @no_news = true
    $tasks[name] = self
  end

  def update
    return if @touched
    source_dir = File.join SOURCE_DIR, @source
    if not File.exists? source_dir
      FileUtils.mkdir_p source_dir
      Dir.chdir source_dir do
        @no_news = not(@repository.clone)
      end
    else
      Dir.chdir source_dir do
        @no_news = not(@repository.update)
      end
    end
  end

  def build(omit_banner = false)
    return if @touched
    for dependency in @dependencies
      run_task dependency
    end if @dependencies and not $options[:omit_dependencies]
    return if not @source # Meta-task
    if not $options[:build_only] and not $options[:force_cmake] and @no_news
      puts "\t\tSkipping build and install phases. Repository was up-to-date"
      puts
      @touched = true
      return
    end
    puts "=== Running task: #{@name} ===" if not omit_banner
    if @build_system == CMAKE
      build_dir = File.join SOURCE_DIR, @source, "build"
      if $options[:force_cmake]
        FileUtils.rm_rf build_dir if File.exists? build_dir
      end
      need_cmake = false
      if not File.exists? build_dir
        Dir.mkdir build_dir
        need_cmake = true
      end
    else
      build_dir = File.join SOURCE_DIR, @source
      need_cmake = true
      @install_command = "sudo make install"
    end
    Dir.chdir build_dir do
      res = nil
      if need_cmake
        info "Running #{@build_system == CMAKE ? "cmake" : "qmake"}"
        own_configs = ""
        if user_has_own_config
          begin
            config = JSON.parse user_own_config
            if config.has_key? @name.to_s and config[@name.to_s].has_key? "configure"
              own_configs = config[@name.to_s]["configure"]
              puts "\t\tUsing own configuration settings: #{own_configs}"
            else
              puts "\t\tNo own configuration settings found. Using defaults"
            end
          rescue JSON::ParserError
            puts "!!! Your own settings file under #{File.join(ENV["HOME"], ".kdebuild")} seems to be an invalid JSON file"
            puts
            puts "    Need help ? Try: http://www.jsonlint.com/"
            Process.exit 1
          end
        end
        if @build_system == CMAKE
          if $options[:verbose]
            system "cmake -DCMAKE_BUILD_TYPE=#{BUILD_TYPE} -DCMAKE_INSTALL_PREFIX=#{INSTALL_PREFIX} #{own_configs} .."
          else
            IO.popen("cmake -DCMAKE_BUILD_TYPE=#{BUILD_TYPE} -DCMAKE_INSTALL_PREFIX=#{INSTALL_PREFIX} #{own_configs} .. &> /dev/null") {}
          end
        else
          if $options[:verbose]
            system "qmake"
          else
            IO.popen("qmake &> /dev/null") {}
          end
        end
      end
      info "Compiling"
      res = nil
      if $options[:verbose]
        res = system "make #{MAKE_OPTIONS}"
      else
        IO.popen("make #{MAKE_OPTIONS} &> /dev/null") {}
        res = ($?.to_i == 0)
      end
      if not res
        $failed_tasks[:build] << self
      else
        info "Installing"
        res = nil
        if $options[:verbose]
          res = system @install_command
        else
          IO.popen("#{@install_command} &> /dev/null") {}
          res = ($?.to_i == 0)
        end
        if not res
          $failed_tasks[:install] << self
        else
          $succeeded_tasks << self
        end
      end
      puts
      @touched = true
    end
  end

  def update_and_build
    return if @touched
    for dependency in @dependencies
      $tasks[dependency].update_and_build if $tasks[dependency]
    end if @dependencies and not $options[:omit_dependencies]
    return if not @source # Meta-task
    puts "=== Running task: #{@name} ==="
    update; build true
  end

end

def print_tasks
  $tasks.each_value do |task|
    if not task.dependencies or task.dependencies.empty?
      puts "\t-> #{task.name} (No dependencies)"
    else
      puts "\t-> #{task.name} (Depends on: #{task.dependencies.join ", "})"
    end
    if task.repository
      puts "\t\t#{task.repository.uri}"
    else
      puts "\t\tMeta task (no repository associated)"
    end
  end
end

def run_task(task)
  the_task = $tasks[task]
  if the_task
    if $options[:build_only]
      the_task.build
    else
      the_task.update_and_build
    end
  else
    puts "!!! Unknown task: #{task}. Existing tasks:"
    print_tasks
  end
end

#### DEFINE TASKS ##############################################################

# KDE support and friends
Task.new :phonon, "phonon", Repository.new("git@git.kde.org:phonon", Repository::GIT_REPO)
Task.new :phonon_gstreamer, "phonon-gstreamer", Repository.new("git@git.kde.org:phonon-gstreamer", Repository::GIT_REPO)
Task.new :phonon_full, nil, nil, [:phonon, :phonon_gstreamer]
Task.new :polkit_qt_1, "polkit-qt-1", Repository.new("git@git.kde.org:polkit-qt-1", Repository::GIT_REPO)
Task.new :automoc, "automoc", Repository.new("git@git.kde.org:automoc", Repository::GIT_REPO)
Task.new :akonadi, "akonadi", Repository.new("git@git.kde.org:akonadi", Repository::GIT_REPO), [:automoc]
Task.new :attica, "attica", Repository.new("git@git.kde.org:attica", Repository::GIT_REPO), [:automoc]
Task.new :soprano, "soprano", Repository.new("git@git.kde.org:soprano", Repository::GIT_REPO), [:automoc]
Task.new :kdesupport, "kde/kdesupport", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/kdesupport", Repository::SVN_REPO), [:phonon_full, :polkit_qt_1, :akonadi, :attica, :soprano]

# KDE
Task.new :kdelibs, "kde/KDE/kdelibs", Repository.new("git@git.kde.org:kdelibs", Repository::GIT_REPO), [:kdesupport]
Task.new :kdepimlibs, "kde/KDE/kdepimlibs", Repository.new("git@git.kde.org:kdepimlibs", Repository::GIT_REPO), [:kdelibs]
Task.new :konsole, "kde/KDE/kdebase-konsole", Repository.new("git@git.kde.org:konsole", Repository::GIT_REPO), [:kdelibs]
Task.new :kate, "kde/KDE/kdebase-kate", Repository.new("git@git.kde.org:kate", Repository::GIT_REPO), [:kdelibs]
Task.new :kde_baseapps, "kde/KDE/kde-baseapps", Repository.new("git@git.kde.org:kde-baseapps", Repository::GIT_REPO), [:kdelibs]
Task.new :kde_workspace, "kde/KDE/kde-workspace", Repository.new("git@git.kde.org:kde-workspace", Repository::GIT_REPO), [:kdelibs]
Task.new :kde_runtime, "kde/KDE/kde-runtime", Repository.new("git@git.kde.org:kde-runtime", Repository::GIT_REPO), [:kdelibs]
Task.new :kdebase, nil, nil, [:kdepimlibs, :konsole, :kate, :kde_baseapps, :kde_workspace, :kde_runtime]
Task.new :kdegraphics, "kde/KDE/kdegraphics", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdegraphics", Repository::SVN_REPO), [:kdelibs]
Task.new :kdemultimedia, "kde/KDE/kdemultimedia", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdemultimedia", Repository::SVN_REPO), [:kdelibs]
Task.new :kdenetwork, "kde/KDE/kdenetwork", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdenetwork", Repository::SVN_REPO), [:kdelibs]
Task.new :kdeplasma_addons, "kde/KDE/kdeplasma-addons", Repository.new("git@git.kde.org:kdeplasma-addons", Repository::GIT_REPO), [:kdelibs]
Task.new :kdesdk, "kde/KDE/kdesdk", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdesdk", Repository::SVN_REPO), [:kdelibs]
Task.new :kdepim_runtime, "kde/KDE/kdepim-runtime", Repository.new("git@git.kde.org:kdepim-runtime", Repository::GIT_REPO), [:kdepimlibs]
Task.new :kdepim, "kde/KDE/kdepim", Repository.new("git@git.kde.org:kdepim", Repository::GIT_REPO), [:kdepim_runtime]
#Task.new :kdeedu, "kde/KDE/kdeedu", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdeedu", Repository::SVN_REPO), [:kdelibs]
Task.new :kdeutils, "kde/KDE/kdeutils", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdeutils", Repository::SVN_REPO), [:kdelibs]
Task.new :kdegames, "kde/KDE/kdegames", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdegames", Repository::SVN_REPO), [:kdelibs]
Task.new :kdetoys, "kde/KDE/kdetoys", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/KDE/kdetoys", Repository::SVN_REPO), [:kdelibs]

# Network management
Task.new :network_management, "networkmanagement", Repository.new("git@git.kde.org:networkmanagement", Repository::GIT_REPO), [:kdebase]

# Webkit KPart
Task.new :kwebkitpart, "kwebkitpart", Repository.new("git@git.kde.org:kwebkitpart", Repository::GIT_REPO), [:kdebase]

# kdereview
Task.new :kdereview, "kde/kdereview", Repository.new("svn+ssh://svn.kde.org/home/kde/trunk/kdereview", Repository::SVN_REPO), [:kdelibs]

# Rekonq
Task.new :rekonq, "kde/rekonq", Repository.new("git@git.kde.org:rekonq", Repository::GIT_REPO), [:kdelibs]

# Gwenview
Task.new :gwenview, "kde/KDE/gwenview", Repository.new("git@git.kde.org:gwenview", Repository::GIT_REPO), [:kdelibs]

# Calligra
Task.new :calligra, "kde/calligra", Repository.new("git@git.kde.org:calligra", Repository::GIT_REPO), [:kdelibs]

# KDevelop
Task.new :kdevplatform, "kdevplatform", Repository.new("git@git.kde.org:kdevplatform", Repository::GIT_REPO), [:kdelibs]
Task.new :kdevelop, "kdevelop", Repository.new("git@git.kde.org:kdevelop", Repository::GIT_REPO), [:kdevplatform]
Task.new :kdevelop_pg_qt, "kdevelop-pg-qt", Repository.new("git@git.kde.org:kdevelop-pg-qt", Repository::GIT_REPO), [:kdevelop]
Task.new :kdevelop_php, "kdevelop-php", Repository.new("git@git.kde.org:kdev-php", Repository::GIT_REPO), [:kdevelop, :kdevelop_pg_qt]
Task.new :kdevelop_php_docs, "kdevelop-php-docs", Repository.new("git@git.kde.org:kdev-php-docs", Repository::GIT_REPO)
Task.new :kdevelop_full, nil, nil, [:kdevelop_php, :kdevelop_php_docs]

# Full KDE distribution
Task.new :full_kde, nil, nil, [:kdebase, :kdegraphics, :kdemultimedia, :kdenetwork, :kdeplasma_addons, :kdesdk, :kdepim, :kdeutils, :kdegames, :kdetoys, :network_management, :kwebkitpart, :kdereview, :rekonq, :gwenview, :calligra, :kdevelop_full]

#### PARSE USER DEFINED TASKS ##################################################

if user_has_own_config
  begin
    config = JSON.parse user_own_config
    config.each do |task, settings|
      next if known_task task
      if not settings.has_key? "repositoryType"
        puts "!!! Task #{task} is missing \"repositoryType\" entry"
        Process.exit 1
      end
      if settings["repositoryType"].downcase != "svn" and settings["repositoryType"].downcase != "git"
        puts "!!! \"repositoryType\" can only be: \"svn\" or \"git\". Found \"#{settings["repositoryType"]}\" at task #{task}"
        Process.exit 1
      end
      if not settings.has_key? "repository"
        puts "!!! Task #{task} is missing \"repository\" entry"
        Process.exit 1
      end
      if settings.has_key? "source"
        source = settings["source"]
      else
        source = task
      end
      repository = Repository.new settings["repository"], (settings["repositoryType"].downcase == "svn" ? Repository::SVN_REPO : Repository::GIT_REPO)
      build_system = Task::CMAKE
      if settings.has_key? "buildSystem"
        if settings["buildSystem"].downcase == "cmake"
          build_system = Task::CMAKE
        elsif settings["buildSystem"].downcase == "qmake"
          build_system = Task::QMAKE
        else
          puts "!!! Unknown buildSystem (#{settings["buildSystem"]}) for task #{task}"
          Process.exit 1
        end
      end
      if settings.has_key? "dependencies"
        if settings["dependencies"].include? task
          puts "!!! Task #{task} includes itself as a dependency. Pretty weird, and the result will probably be 42"
          Process.exit 1
        end
        Task.new task.to_sym, source, repository, settings["dependencies"].map { |e|
          d = e.to_sym
          if not known_task d
            puts "!!! Task #{task} depends on unknown task #{e}"
            Process.exit 1
          end
          d
        }, build_system
      else
        Task.new task.to_sym, source, repository, nil, build_system
      end
    end
  rescue JSON::ParserError
    puts "!!! Your own settings file under #{File.join(ENV["HOME"], ".kdebuild")} seems to be an invalid JSON file"
    puts
    puts "    Need help ? Try: http://www.jsonlint.com/"
    Process.exit 1
  end
end

#### PARSE ARGUMENTS AND START WORKING #########################################

require "optparse"

OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename $0} [-bofv] [-l] [task1, task2, ...]"
  opts.on("-b", "--build-only", "Do not update. Only build") do
    $options[:build_only] = true
  end
  opts.on("-o", "--omit-dependencies", "Omit dependencies. Execute only the provided tasks") do
    $options[:omit_dependencies] = true
  end
  opts.on("-f", "--force-cmake", "Force CMake (or qmake) execution. Cleans old build(s)") do
    $options[:force_cmake] = true
  end
  opts.on("-v", "--verbose", "Output verbosity") do
    $options[:verbose] = true
  end
  opts.on("-l", "--list-available-tasks", "List available tasks") do
    $options[:list_available_tasks] = true
  end
end.parse!

if $options[:list_available_tasks]
  puts "Available tasks:"
  print_tasks
  Process.exit
end

if ARGV.empty?
  run_task :full_kde
else
  for arg in ARGV
    run_task arg.to_sym
  end
end

$failed_tasks.each do |phase, tasks|
  next if tasks.empty?
  puts "!!! Failed tasks at #{phase} phase"
  tasks.each do |task|
    puts "\t- #{task.name}"
  end
end

if not $succeeded_tasks.empty?
  puts "*** Succeeded tasks:"
  $succeeded_tasks.each do |task|
    puts "\t- #{task.name}"
  end
end
